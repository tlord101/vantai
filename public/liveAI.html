<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vant Ai</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <style>
        :root {
            --border-color: rgba(255, 255, 255, 0.3);
            --border-active: #ffffff;
            --text-color: #ffffff;
            --bg-transparent: rgba(0, 0, 0, 0.4);
            --toast-error: #ff4444;
            --toast-info: #4285f4;
            --toast-warn: #ffbb33;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            background-color: #000;
            color: var(--text-color);
            height: 100vh;
            width: 100vw;
        }

        #video-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(1); 
            z-index: -1;
            transition: transform 0.5s ease;
        }
        
        #video-bg.mirrored {
            transform: scaleX(-1);
        }

        #toast-container {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 90%;
            max-width: 450px;
            pointer-events: none;
        }

        .toast {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            padding: 14px 18px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-size: 13px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.6);
            animation: slideDown 0.3s ease-out forwards;
            pointer-events: auto;
            line-height: 1.4;
        }

        .toast.error { border-left: 4px solid var(--toast-error); }
        .toast.info { border-left: 4px solid var(--toast-info); }
        .toast.warn { border-left: 4px solid var(--toast-warn); }

        @keyframes slideDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }

        #ui-layer {
            position: relative;
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 24px;
            box-sizing: border-box;
            background: radial-gradient(circle, transparent 20%, rgba(0,0,0,0.4) 100%);
        }

        .top-bar { display: flex; justify-content: space-between; align-items: center; }

        .status-container {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #555;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }
        .status-dot.live { background-color: #00ff41; box-shadow: 0 0 8px #00ff41; }
        .status-dot.error { background-color: var(--toast-error); box-shadow: 0 0 8px var(--toast-error); }
        .status-dot.connecting { background-color: var(--toast-warn); animation: pulse 1s infinite; }

        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

        .app-title {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 3px;
            text-transform: uppercase;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 4px;
        }

        .top-actions {
            display: flex;
            gap: 15px;
        }

        .btn-icon {
            background: transparent;
            border: none;
            color: var(--text-color);
            font-size: 1.3rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s, transform 0.2s;
            padding: 5px;
        }
        .btn-icon:hover { opacity: 1; transform: scale(1.1); }

        #settings-modal {
            position: absolute;
            top: 70px;
            right: 24px;
            width: 250px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid var(--border-color);
            padding: 24px;
            border-radius: 12px;
            display: none;
            backdrop-filter: blur(15px);
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }
        #settings-modal.show { display: block; animation: fadeIn 0.2s ease-out; }

        .form-group { margin-bottom: 16px; }
        .form-label { font-size: 10px; text-transform: uppercase; display: block; margin-bottom: 6px; color: #aaa; letter-spacing: 1px;}
        .form-input {
            width: 100%;
            background: rgba(255,255,255,0.08);
            border: 1px solid #444;
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-family: inherit;
            font-size: 12px;
            box-sizing: border-box;
            transition: border-color 0.2s;
        }
        .form-input:focus { outline: none; border-color: white; }

        #transcript-overlay {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 700px;
            text-align: center;
            pointer-events: none;
        }

        #transcriptText {
            font-size: 1.1rem;
            line-height: 1.6;
            text-shadow: 0 2px 4px rgba(0,0,0,0.9);
            background: linear-gradient(to right, rgba(0,0,0,0), rgba(0,0,0,0.6), rgba(0,0,0,0));
            padding: 10px;
            border-radius: 4px;
        }
        
        .controls-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
            margin-bottom: 70px; /* Shifted UP by 10px (was 20px) */
        }

        #actionBtn {
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 14px 32px;
            border-radius: 30px;
            font-family: inherit;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            backdrop-filter: blur(4px);
        }

        #actionBtn:hover {
            border-color: var(--border-active);
            background: rgba(255,255,255,0.1);
            transform: scale(1.02);
        }

        .audio-waves {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            height: 24px;
            opacity: 0.3;
            transition: opacity 0.3s;
        }
        .audio-waves.active { opacity: 1; }
        .bar { width: 3px; background: white; height: 20%; border-radius: 2px; transition: height 0.1s; }
        canvas { display: none; }
    </style>
</head>
<body>

    <video id="video-bg" autoplay playsinline muted></video>
    <div id="toast-container"></div>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="status-container">
                <div id="statusDot" class="status-dot"></div>
                <span id="statusText">Offline</span>
            </div>
            <div class="app-title">Vant Ai</div>
            
            <div class="top-actions">
                <button id="switchCamBtn" class="btn-icon" title="Switch Camera">
                    <i class="bi bi-arrow-repeat"></i>
                </button>
                <button id="settingsBtn" class="btn-icon" title="Settings">
                    <i class="bi bi-gear"></i>
                </button>
            </div>
        </div>

        <div id="settings-modal">
            <div class="form-group">
                <label class="form-label">Voice</label>
                <select id="voiceSelect" class="form-input">
                    <option value="Puck">Puck (Male)</option>
                    <option value="Charon">Charon (Male)</option>
                    <option value="Kore">Kore (Female)</option>
                    <option value="Fenrir">Fenrir (Male)</option>
                    <option value="Aoede">Aoede (Female)</option>
                </select>
            </div>
            <div style="text-align: right;">
                <button id="closeSettings" class="form-input" style="width: auto; border: 1px solid #777; cursor: pointer;">DONE</button>
            </div>
        </div>

        <div id="transcript-overlay">
            <span id="transcriptText"></span>
        </div>

        <div class="controls-area">
            <div id="visualizer" class="audio-waves">
                <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
            </div>

            <button id="actionBtn">
                <i id="actionIcon" class="bi bi-mic-fill"></i>
                <span id="actionText">Start Session</span>
            </button>
        </div>
    </div>

    <canvas id="processCanvas"></canvas>

    <script>
        const VantKey = "AIzaSyDVRaBh8YkiFoDG2GDt9szZVSypM6AyO0s";

        const CONFIG = {
            model: 'models/gemini-2.0-flash-exp',
            url: 'wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent'
        };

        const state = {
            isConnected: false,
            socket: null,
            audioContext: null,
            mediaStream: null,
            audioSourceNode: null,
            audioProcessor: null,
            videoInterval: null,
            nextPlayTime: 0,
            facingMode: 'user' // 'user' or 'environment'
        };

        const els = {
            videoBg: document.getElementById('video-bg'),
            canvas: document.getElementById('processCanvas'),
            ctx: document.getElementById('processCanvas').getContext('2d'),
            actionBtn: document.getElementById('actionBtn'),
            actionText: document.getElementById('actionText'),
            actionIcon: document.getElementById('actionIcon'),
            settingsBtn: document.getElementById('settingsBtn'),
            switchCamBtn: document.getElementById('switchCamBtn'),
            settingsModal: document.getElementById('settings-modal'),
            closeSettings: document.getElementById('closeSettings'),
            voice: document.getElementById('voiceSelect'),
            statusDot: document.getElementById('statusDot'),
            statusText: document.getElementById('statusText'),
            transcript: document.getElementById('transcriptText'),
            visualizer: document.getElementById('visualizer'),
            toastContainer: document.getElementById('toast-container')
        };

        async function initCamera() {
            try {
                if (state.mediaStream) {
                    state.mediaStream.getTracks().forEach(track => track.stop());
                }

                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 }, 
                        facingMode: state.facingMode 
                    },
                    audio: { 
                        sampleRate: 16000, 
                        channelCount: 1,
                        echoCancellation: true 
                    }
                });

                els.videoBg.srcObject = stream;
                state.mediaStream = stream;

                if(state.facingMode === 'user') {
                    els.videoBg.classList.add('mirrored');
                } else {
                    els.videoBg.classList.remove('mirrored');
                }

                if (state.isConnected && state.audioContext && state.audioProcessor) {
                    if(state.audioSourceNode) {
                        state.audioSourceNode.disconnect();
                    }
                    state.audioSourceNode = state.audioContext.createMediaStreamSource(stream);
                    state.audioSourceNode.connect(state.audioProcessor);
                }

            } catch (e) {
                console.error(e);
                showToast("Camera Error: " + e.message, "error");
            }
        }
        
        initCamera();

        els.switchCamBtn.onclick = () => {
            state.facingMode = state.facingMode === 'user' ? 'environment' : 'user';
            initCamera();
        };

        els.settingsBtn.onclick = () => els.settingsModal.classList.toggle('show');
        els.closeSettings.onclick = () => els.settingsModal.classList.remove('show');
        els.actionBtn.onclick = () => state.isConnected ? disconnect() : connect();

        async function connect() {
            setUIState('connecting');

            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                state.audioContext = new AudioContext({ sampleRate: 24000 });
                if (state.audioContext.state === 'suspended') await state.audioContext.resume();
                state.nextPlayTime = state.audioContext.currentTime + 0.1;

                const wsUrl = `${CONFIG.url}?key=${VantKey}`;
                state.socket = new WebSocket(wsUrl);

                state.socket.onopen = () => {
                    const setupMsg = {
                        setup: {
                            model: CONFIG.model,
                            generationConfig: {
                                responseModalities: ["AUDIO"],
                                speechConfig: {
                                    voiceConfig: { prebuiltVoiceConfig: { voiceName: els.voice.value } }
                                }
                            }
                        }
                    };
                    state.socket.send(JSON.stringify(setupMsg));
                };

                state.socket.onmessage = handleServerMessage;
                
                state.socket.onclose = (e) => {
                    if (e.code === 1007) showToast("Error 1007: Invalid Config.", "error");
                    else if (e.code === 1006) showToast("Connection Failed (1006).", "error");
                    else if (e.code !== 1000) showToast(`Disconnected: Code ${e.code}`, "error");
                    disconnect();
                };

            } catch (e) {
                showToast("Init Error: " + e.message, "error");
                disconnect();
            }
        }

        async function handleServerMessage(event) {
            let data;
            try {
                data = JSON.parse(event.data instanceof Blob ? await event.data.text() : event.data);
            } catch (e) { return; }

            if (data.setupComplete) {
                setUIState('connected');
                showToast("Vant Ai Connected", "info");
                startMediaStreaming();
                return;
            }

            if (data.serverContent?.modelTurn?.parts) {
                const parts = data.serverContent.modelTurn.parts;
                for (const part of parts) {
                    if (part.text) typeWriter(part.text);
                    if (part.inlineData && part.inlineData.mimeType.startsWith('audio/pcm')) {
                        queueAudio(part.inlineData.data);
                    }
                }
            }
        }

        function startMediaStreaming() {
            if (!state.socket || !state.mediaStream) return;

            state.audioSourceNode = state.audioContext.createMediaStreamSource(state.mediaStream);
            state.audioProcessor = state.audioContext.createScriptProcessor(4096, 1, 1);
            
            state.audioProcessor.onaudioprocess = (e) => {
                if (!state.isConnected) return;
                const inputData = e.inputBuffer.getChannelData(0);
                const downsampled = downsampleBuffer(inputData, state.audioContext.sampleRate, 16000);
                const pcm16 = floatTo16BitPCM(downsampled);
                const base64 = arrayBufferToBase64(pcm16.buffer);
                
                if(state.socket.readyState === WebSocket.OPEN) {
                    state.socket.send(JSON.stringify({
                        realtimeInput: { mediaChunks: [{ mimeType: "audio/pcm", data: base64 }] }
                    }));
                }
            };
            
            state.audioSourceNode.connect(state.audioProcessor);
            state.audioProcessor.connect(state.audioContext.destination);

            state.videoInterval = setInterval(() => {
                if (!state.isConnected || state.socket.readyState !== WebSocket.OPEN) return;
                
                const w = 320, h = 240;
                els.canvas.width = w; els.canvas.height = h;
                
                els.ctx.drawImage(els.videoBg, 0, 0, w, h);
                const base64 = els.canvas.toDataURL('image/jpeg', 0.5).split(',')[1];
                
                state.socket.send(JSON.stringify({
                    realtimeInput: { mediaChunks: [{ mimeType: "image/jpeg", data: base64 }] }
                }));
            }, 500);
        }

        function queueAudio(base64Data) {
            const arrayBuffer = base64ToArrayBuffer(base64Data);
            const pcm16 = new Int16Array(arrayBuffer);
            const float32 = new Float32Array(pcm16.length);
            for (let i = 0; i < pcm16.length; i++) float32[i] = pcm16[i] / 32768.0;

            const buffer = state.audioContext.createBuffer(1, float32.length, 24000);
            buffer.getChannelData(0).set(float32);
            const source = state.audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(state.audioContext.destination);
            
            const currentTime = state.audioContext.currentTime;
            if (state.nextPlayTime < currentTime) state.nextPlayTime = currentTime;
            source.start(state.nextPlayTime);
            state.nextPlayTime += buffer.duration;
            animateVisualizer(buffer.duration * 1000);
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `<i class="bi ${type === 'error' ? 'bi-exclamation-triangle-fill' : 'bi-info-circle-fill'}"></i><span>${message}</span>`;
            els.toastContainer.appendChild(toast);
            setTimeout(() => toast.remove(), 4000);
        }

        function setUIState(status) {
            if (status === 'connecting') {
                els.actionText.textContent = "Connecting...";
                els.actionBtn.disabled = true;
                els.statusText.textContent = "Connecting";
                els.statusDot.className = "status-dot connecting";
            } else if (status === 'connected') {
                state.isConnected = true;
                els.actionText.textContent = "End Session";
                els.actionIcon.className = "bi bi-stop-circle-fill";
                els.actionBtn.style.borderColor = "#ff4444";
                els.actionBtn.disabled = false;
                els.statusText.textContent = "Live";
                els.statusDot.className = "status-dot live";
            } else {
                els.actionText.textContent = "Start Session";
                els.actionIcon.className = "bi bi-mic-fill";
                els.actionBtn.style.borderColor = "var(--border-color)";
                els.actionBtn.disabled = false;
                els.statusText.textContent = "Offline";
                els.statusDot.className = "status-dot error";
                els.transcript.textContent = "";
            }
        }

        function disconnect() {
            if (state.socket) { state.socket.close(); state.socket = null; }
            if (state.audioProcessor) { state.audioProcessor.disconnect(); state.audioProcessor = null; }
            if (state.audioSourceNode) { state.audioSourceNode.disconnect(); state.audioSourceNode = null; }
            if (state.videoInterval) clearInterval(state.videoInterval);
            state.isConnected = false;
            setUIState('disconnected');
        }

        function downsampleBuffer(buffer, inputRate, outputRate) {
            if (outputRate === inputRate) return buffer;
            const ratio = inputRate / outputRate;
            const newLength = Math.round(buffer.length / ratio);
            const result = new Float32Array(newLength);
            let offsetResult = 0, offsetBuffer = 0;
            while (offsetResult < result.length) {
                const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
                let accum = 0, count = 0;
                for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) { accum += buffer[i]; count++; }
                result[offsetResult] = count > 0 ? accum / count : 0;
                offsetResult++; offsetBuffer = nextOffsetBuffer;
            }
            return result;
        }

        function floatTo16BitPCM(input) {
            const output = new Int16Array(input.length);
            for (let i = 0; i < input.length; i++) {
                const s = Math.max(-1, Math.min(1, input[i]));
                output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return output;
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
            return window.btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
            return bytes.buffer;
        }

        let typeTimeout;
        function typeWriter(text) {
            const el = els.transcript;
            if (text.length > 50) el.textContent = "";
            let i = 0;
            function type() {
                if (i < text.length) { el.textContent += text.charAt(i); i++; typeTimeout = setTimeout(type, 30); }
            }
            type();
        }

        function animateVisualizer(duration) {
            els.visualizer.classList.add('active');
            const bars = document.querySelectorAll('.bar');
            const interval = setInterval(() => { bars.forEach(bar => bar.style.height = Math.random() * 100 + '%'); }, 100);
            setTimeout(() => { clearInterval(interval); els.visualizer.classList.remove('active'); bars.forEach(bar => bar.style.height = '20%'); }, duration);
        }
    </script>
</body>
</html>


